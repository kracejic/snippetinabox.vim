priority -50


snippet cc "Filename::"
${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}::
endsnippet

snippet sing "singleton"
#pragma once

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
private:
public:
	static $1& getInstance(){
		static $1 instance;
		return instance;
	};
	$1() {$2};
	$1($1 const&); //don't implement
	void operator=($1 const&); //don't implement
};

endsnippet

snippet be "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet defmove "default move and copy constructor"
${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}(const $1& p) = default;
$1& operator=(const $1& p) = default;
$1($1&& p) = default;
$1& operator=($1&& p) = default;
endsnippet

snippet forr "for range"
for (auto &${1:i} : ${2:v})
{
	$3
}
endsnippet

snippet cout "cout<<'x='<<x<<'\\n'"
std::cout<<"${1:i} = "<<$1<<"\n";
endsnippet

snippet std "std::"
std::$1
endsnippet

snippet temp "template <class T>"
template <class ${1:T}>
endsnippet

snippet tfun "templated function"
template <class ${1:T}>
${2:auto} ${3:function_name} ($4)
{
	$5
}
endsnippet

snippet t "this->"
this->$1
endsnippet

snippet un "using namespace"
using namespace $1;
endsnippet

snippet up "unique pointer"
std::unique_ptr<$1> ${2:var};
endsnippet

snippet mu "make unique pointer"
std::make_unique<$1>(${2:var});
endsnippet

snippet sp "shared pointer"
std::shared_ptr<$1> ${2:var};
endsnippet

snippet ms "make shared pointer"
std::make_shared<$1>(${2:var});
endsnippet


snippet i8 "int8_t"
int8_t ${1:var}${2: = 0};
endsnippet

snippet i16 "int16_t"
int16_t ${1:var}${2: = 0};
endsnippet

snippet i32 "int32_t"
int32_t ${1:var}${2: = 0};
endsnippet

snippet i64 "int64_t"
int64_t ${1:var}${2: = 0};
endsnippet

snippet u8 "uint8_t"
uint8_t ${1:var}${2: = 0};
endsnippet

snippet u16 "uint16_t"
uint16_t ${1:var}${2: = 0};
endsnippet

snippet u32 "uint32_t"
uint32_t ${1:var}${2: = 0};
endsnippet

snippet u64 "uint64_t"
uint64_t ${1:var}${2: = 0};
endsnippet


snippet main "extended main"
#include <vector>
#include <string>
#include <iostream>
#include <stdio.h>
#include <fstream>

//g++ `!v expand('%:t')` -std=c++14 -o a.exe && ./a.exe

using namespace std;

int main(int argc, char const *argv[])
{
	${2:cout<<"hello world!"<<endl;

	ifstream file("filename.txt");
	string s2;
	while (getline(file, s2)) //any newline will stop the reading
		cout << s2 << endl;
}

	return 0;
}
endsnippet


snippet async "std::async"
async(${1:std::launch::async, }[${2:this}](${3}){
	${4:return true;}
});
endsnippet

# spdlog snippets
snippet ll "L->debug(a, a)"
L->debug("${1:var} = {}", $1);
endsnippet

snippet l "L->debug()"
L->debug("${1:log}"${2});
endsnippet

snippet debug "L->debug()"
L->debug("${1:log}"${2});
endsnippet

snippet info "L->info()"
L->info("${1:log}"${2});
endsnippet

snippet warn "L->warn()"
L->warn("${1:log}"${2});
endsnippet

snippet error "L->error()"
L->error("${1:log}"${2});
endsnippet


#------------------------------------------------------------------------------
# Catch

snippet catch "catch unittest with quards"
//-----------------------------------------------------------------------------
#ifdef UNIT_TESTS
#include "catch.hpp"

TEST_CASE("$1")
{
	$2
	REQUIRE($3);
}

#endif
endsnippet

snippet test "catch unittest"
TEST_CASE("$1")
{
	$2
	REQUIRE($3);
}
endsnippet

snippet req "catch REQUIRE"
REQUIRE($1);
endsnippet

#------------------------------------------------------------------------------
