priority -50


snippet inc "include"
#include "${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`.h}"
endsnippet

snippet Inc "include <>"
#include <${1:string}>
endsnippet

snippet incjson "include json"
#include "json.hpp"
using json = nlohmann::json;
endsnippet

snippet cr "const reference"
const ${1:std::string}& $2
endsnippet

snippet cc "Filename::"
${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}::
endsnippet

snippet sing "singleton"
#pragma once

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
public:
	static $1& instance(){
		static $1 instance;
		return instance;
	};
private:
	$1() {$2};
	$1($1 const&) = delete;
	void operator=($1 const&) = delete;
};
endsnippet

snippet singl "singleton lazy"
#pragma once
#include <memory>

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
public:
	static $1& instance(){
		static std::unique_ptr<$1> instance;
		if (not instance)
			instance.reset(new $1());
		return *instance;
	};
private:
	$1() {$2};
	$1($1 const&) = delete;
	void operator=($1 const&) = delete;
};
endsnippet

snippet loadjson "load file to json"
ifstream cfg_file(${1:filaneme});

if (not cfg_file)
	return;
json cfg;
cfg_file >> cfg;
endsnippet

snippet be "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet defmove "default move and copy constructor"
${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}(const $1& p) = default;
$1& operator=(const $1& p) = default;
$1($1&& p) = default;
$1& operator=($1&& p) = default;
endsnippet

snippet forr "for range"
for (auto &${1:i} : ${2:v})
{
	$3
}
endsnippet

snippet cout "cout<<'x='<<x<<'\\n'"
std::cout<<"${1:i} = "<<$1<<"\n";
endsnippet

snippet std "std::"
std::$1
endsnippet

snippet temp "template <class T>"
template <class ${1:T}>
endsnippet

snippet enum "enum class"
enum class ${1:name}
{
	$2
};
endsnippet

snippet po "pragma once"
#pragma once
endsnippet

snippet struct "struct"
struct ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
	$2
};
endsnippet

snippet class "class"
class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
public:
	$3
private:
	$2
};
endsnippet

snippet strl "string literal"
R"($1)"
endsnippet

snippet str "string"
std::string ${1:text}
endsnippet

snippet cstr "const std::string&"
const std::string& ${1:text}
endsnippet

snippet mut "std::mutex"
std::mutex ${1:lock}
endsnippet

snippet lock "std::unique_lock"
std::unique_lock<std::mutex> lock(${1:lock});
endsnippet

snippet alg "std::algorithm(begin, end);"
${1:std::sort}(${2:v}.begin(), $2.end()${3:, [](auto& it$4){$5}})
endsnippet

snippet fun "function"
${1:void} ${2:foo}($3)
{
	$4
}
endsnippet

snippet tfun "templated function"
template <class ${1:T}>
${2:auto} ${3:function_name} ($4)
{
	$5
}
endsnippet

snippet cfun "void Filename::Foo(){}"
${1:void} ${2:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}::${3:foo}($4)
{
	$5
}
endsnippet

snippet { "{}"
{
	$1
}
endsnippet

snippet [ "[]"
[$1]$2
endsnippet

snippet ( "()"
($1)$2
endsnippet

snippet t "this->"
this->$1
endsnippet

snippet alias "namespace"
namespace ${1:ch} = ${2:std::chrono};
endsnippet

snippet us "namespace"
namespace ${1:ch} = ${2:std::chrono};
endsnippet

snippet un "using namespace"
using namespace $1;
endsnippet

snippet ns "namespace"
namespace ${1:_detail}
{
	$2
}
endsnippet

snippet up "unique pointer"
std::unique_ptr<$1> ${2:var}
endsnippet

snippet mu "make unique pointer"
std::make_unique<$1>(${2:var})
endsnippet

snippet sp "shared pointer"
std::shared_ptr<$1> ${2:var}
endsnippet

snippet ms "make shared pointer"
std::make_shared<$1>(${2:var})
endsnippet

snippet uc "unsigned char"
unsigned char ${1:var}
endsnippet

snippet i8 "int8_t"
int8_t ${1:var}
endsnippet

snippet i16 "int16_t"
int16_t ${1:var}
endsnippet

snippet i32 "int32_t"
int32_t ${1:var}
endsnippet

snippet i64 "int64_t"
int64_t ${1:var}
endsnippet

snippet u8 "uint8_t"
uint8_t ${1:var}
endsnippet

snippet u16 "uint16_t"
uint16_t ${1:var}
endsnippet

snippet u32 "uint32_t"
uint32_t ${1:var}
endsnippet

snippet u64 "uint64_t"
uint64_t ${1:var}
endsnippet

snippet set "setter"
void set${1/(.)(.*)/\u$1$2/}(${2:const std::string&} _${1:var}) {$1 = _$1;};
endsnippet
snippet get "getter"
${2:const std::string&} get${1/(.)(.*)/\u$1$2/}() {return ${1:var};};
endsnippet
snippet setget "setter and getter"
void set${1/(.)(.*)/\u$1$2/}(${2:const std::string&} _${1:var}) {$1 = _$1;};
$2 get${1/(.)(.*)/\u$1$2/}() {return $1;};
endsnippet

snippet //cf "clang-format on/off"
// clang-format off
// clang-format on
endsnippet
snippet //co "clang-format on/off"
// clang-format off
// clang-format on
endsnippet
snippet //clang "clang-format on/off"
// clang-format off
// clang-format on
endsnippet

snippet // "comment block"
/**
 * $1
 */
endsnippet

snippet /* "comment block"
/**
 * $1
 */
endsnippet

snippet load "load file to string"
std::ifstream file(${1:"file.txt"});
file.seekg(0, std::ios::end);
std::string ${2:buffer};
$2.reserve(file.tellg());
file.seekg(0, std::ios::beg);
$2.assign((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
${3:#include <string>
#include <fstream>
#include <streambuf> }
endsnippet

snippet main "extended main"
#include <vector>
#include <string>
#include <iostream>
#include <stdio.h>
#include <fstream>

//g++ `!v expand('%:t')` -std=c++14 -o a.exe && ./a.exe

using namespace std;

int main(int argc, char const *argv[])
{
	${2:cout<<"hello world!"<<endl;

	ifstream file("filename.txt");
	string s2;
	while (getline(file, s2)) //any newline will stop the reading
		cout << s2 << endl;
}

	return 0;
}
endsnippet


snippet async "std::async"
async(${1:std::launch::async, }[${2:this}](${3}){
	${4:return true;}
});
endsnippet

# spdlog snippets
snippet ll "L->debug(a, a)"
L->${3:debug}("${1:var} = {}", $1);
endsnippet

snippet l "L->debug()"
L->debug("${1:log}"${2});
endsnippet

snippet debug "L->debug()"
L->debug("${1:log}"${2});
endsnippet

snippet info "L->info()"
L->info("${1:log}"${2});
endsnippet

snippet warn "L->warn()"
L->warn("${1:log}"${2});
endsnippet

snippet error "L->error()"
L->error("${1:log}"${2});
endsnippet

snippet sc "static_cast"
static_cast<$1>($2)
endsnippet

snippet rc "reinterpret_cast"
reinterpret_cast<$1>($2)
endsnippet

snippet dc "dynamic_cast"
dynamic_cast<$1>($2)
endsnippet

snippet ccast "const_cast"
const_cast<$1>($2)
endsnippet


#------------------------------------------------------------------------------
# Catch

snippet catch "catch unittest with quards"
//-----------------------------------------------------------------------------
#ifdef UNIT_TESTS
#include "catch.hpp"

TEST_CASE("$1")
{
	$2
	REQUIRE($3);
}

#endif
endsnippet

snippet test "catch unittest"
TEST_CASE("$1")
{
	$2
	REQUIRE($3);
}
endsnippet

snippet req "catch REQUIRE"
REQUIRE($1);
endsnippet

#------------------------------------------------------------------------------
