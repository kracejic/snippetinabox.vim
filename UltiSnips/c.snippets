priority -50


snippet inc "include"
#include "${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}.h"
endsnippet

snippet Inc "include <>"
#include <${1:string}>
endsnippet

snippet cc "Filename::"
${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}::
endsnippet

snippet sing "singleton"
#pragma once

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
private:
public:
	static $1& getInstance(){
		static $1 instance;
		return instance;
	};
	$1() {$2};
	$1($1 const&); //don't implement
	void operator=($1 const&); //don't implement
};

endsnippet

snippet be "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet defmove "default move and copy constructor"
${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}(const $1& p) = default;
$1& operator=(const $1& p) = default;
$1($1&& p) = default;
$1& operator=($1&& p) = default;
endsnippet

snippet forr "for range"
for (auto &${1:i} : ${2:v})
{
	$3
}
endsnippet

snippet cout "cout<<'x='<<x<<'\\n'"
std::cout<<"${1:i} = "<<$1<<"\n";
endsnippet

snippet std "std::"
std::$1
endsnippet

snippet temp "template <class T>"
template <class ${1:T}>
endsnippet

snippet enum "enum class"
enum class ${1:name}
{
	$2
};
endsnippet

snippet struct "struct"
struct ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
	$2
};
endsnippet

snippet class "struct"
class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
private:
	$2
public:
	$3
};
endsnippet

snippet strl "string literal"
R"($1)"
endsnippet

snippet str "string"
std::string ${1:text}
endsnippet

snippet mut "std::mutex"
std::mutex ${1:lock}
endsnippet

snippet lock "std::unique_lock"
std::unique_lock<std::mutex> lock(${1:lock});
endsnippet

snippet alg "std::algorithm(begin, end);"
${1:sort}(${2:v}.begin(), $2.end()${3:, [](auto& it$4){$5}})
endsnippet

snippet fun "function"
${1:void} ${2:foo}($3)
{
	$4
}
endsnippet

snippet tfun "templated function"
template <class ${1:T}>
${2:auto} ${3:function_name} ($4)
{
	$5
}
endsnippet

snippet cfun "void Filename::Foo(){}"
${1:void} ${2:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}::${3:foo}($4)
{
	$5
}
endsnippet

snippet t "this->"
this->$1
endsnippet

snippet un "using namespace"
using namespace $1;
endsnippet

snippet up "unique pointer"
std::unique_ptr<$1> ${2:var}
endsnippet

snippet mu "make unique pointer"
std::make_unique<$1>(${2:var})
endsnippet

snippet sp "shared pointer"
std::shared_ptr<$1> ${2:var}
endsnippet

snippet ms "make shared pointer"
std::make_shared<$1>(${2:var})
endsnippet


snippet i8 "int8_t"
int8_t ${1:var}
endsnippet

snippet i16 "int16_t"
int16_t ${1:var}
endsnippet

snippet i32 "int32_t"
int32_t ${1:var}
endsnippet

snippet i64 "int64_t"
int64_t ${1:var}
endsnippet

snippet u8 "uint8_t"
uint8_t ${1:var}
endsnippet

snippet u16 "uint16_t"
uint16_t ${1:var}
endsnippet

snippet u32 "uint32_t"
uint32_t ${1:var}
endsnippet

snippet u64 "uint64_t"
uint64_t ${1:var}
endsnippet

snippet load "load file to string"
std::ifstream file(${1:"file.txt"});
file.seekg(0, std::ios::end);
std::string ${2:buffer};
$2.reserve(file.tellg());
file.seekg(0, std::ios::beg);
$2.assign((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
${3:#include <string>
#include <fstream>
#include <streambuf> }
endsnippet

snippet main "extended main"
#include <vector>
#include <string>
#include <iostream>
#include <stdio.h>
#include <fstream>

//g++ `!v expand('%:t')` -std=c++14 -o a.exe && ./a.exe

using namespace std;

int main(int argc, char const *argv[])
{
	${2:cout<<"hello world!"<<endl;

	ifstream file("filename.txt");
	string s2;
	while (getline(file, s2)) //any newline will stop the reading
		cout << s2 << endl;
}

	return 0;
}
endsnippet


snippet async "std::async"
async(${1:std::launch::async, }[${2:this}](${3}){
	${4:return true;}
});
endsnippet

# spdlog snippets
snippet ll "L->debug(a, a)"
L->${3:debug}("${1:var} = {}", $1);
endsnippet

snippet l "L->debug()"
L->debug("${1:log}"${2});
endsnippet

snippet debug "L->debug()"
L->debug("${1:log}"${2});
endsnippet

snippet info "L->info()"
L->info("${1:log}"${2});
endsnippet

snippet warn "L->warn()"
L->warn("${1:log}"${2});
endsnippet

snippet error "L->error()"
L->error("${1:log}"${2});
endsnippet


#------------------------------------------------------------------------------
# Catch

snippet catch "catch unittest with quards"
//-----------------------------------------------------------------------------
#ifdef UNIT_TESTS
#include "catch.hpp"

TEST_CASE("$1")
{
	$2
	REQUIRE($3);
}

#endif
endsnippet

snippet test "catch unittest"
TEST_CASE("$1")
{
	$2
	REQUIRE($3);
}
endsnippet

snippet req "catch REQUIRE"
REQUIRE($1);
endsnippet

#------------------------------------------------------------------------------
